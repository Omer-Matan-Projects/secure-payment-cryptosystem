"""
Elliptic Curve arithmetic for secp256k1 implementation.

Curve: y^2 = x^3 + 7 over F_p
Parameters are the standard secp256k1 domain parameters.

Point representation:
- None represents the point at infinity (identity element).
- Otherwise, a point is a tuple (x, y) with 0 <= x,y < p.
"""

from __future__ import annotations
from typing import Optional, Tuple

Point = Optional[Tuple[int, int]]


# --- Domain parameters (secp256k1) ---

# Field prime
P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F

# Curve coefficients: y^2 = x^3 + A*x + B
A = 0
B = 7

# Base point (generator) G
Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8
G: Point = (Gx, Gy)

# Order of the subgroup generated by G
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141


# --- Modular arithmetic utilities ---

def _egcd(a: int, b: int) -> tuple[int, int, int]:
    """
    Return (g, x, y) such that a*x + b*y = g = gcd(a, b).
    """
    if b == 0:
        return (a, 1, 0)
    g, x1, y1 = _egcd(b, a % b)
    return (g, y1, x1 - (a // b) * y1)


def modinv(a: int, m: int) -> int:
    """
    Return a^{-1} mod m (raises if inverse does not exist).
    """
    a %= m
    g, x, _ = _egcd(a, m)
    if g != 1:
        raise ValueError("No modular inverse exists.")
    return x % m


def is_on_curve(Pt: Point) -> bool:
    """
    Check whether a point lies on the curve (or is infinity).
    """
    if Pt is None:
        return True
    x, y = Pt
    return (y * y - (x * x * x + A * x + B)) % P == 0


# --- EC group operations (affine coordinates) ---

def point_neg(Pt: Point) -> Point:
    """
    Return -Pt.
    """
    if Pt is None:
        return None
    x, y = Pt
    return (x, (-y) % P)


def point_add(P1: Point, P2: Point) -> Point:
    """
    Add two points in affine coordinates.

    Rules:
    - O + P = P
    - P + (-P) = O
    - Use slope formula for addition/doubling
    """
    if P1 is None:
        return P2
    if P2 is None:
        return P1

    x1, y1 = P1
    x2, y2 = P2

    if x1 == x2 and (y1 + y2) % P == 0:
        return None  # point at infinity

    if P1 != P2:
        # slope = (y2 - y1) / (x2 - x1)
        denom = (x2 - x1) % P
        lam = ((y2 - y1) * modinv(denom, P)) % P
    else:
        # slope = (3*x1^2 + A) / (2*y1)
        if y1 == 0:
            return None
        denom = (2 * y1) % P
        lam = ((3 * x1 * x1 + A) * modinv(denom, P)) % P

    x3 = (lam * lam - x1 - x2) % P
    y3 = (lam * (x1 - x3) - y1) % P
    return (x3, y3)


def scalar_mult(k: int, Pt: Point) -> Point:
    """
    Compute k*Pt using double-and-add.

    k is reduced mod N for typical signature usage.
    """
    if Pt is None:
        return None
    k %= N
    if k == 0:
        return None

    result: Point = None
    addend: Point = Pt

    while k:
        if k & 1:
            result = point_add(result, addend)
        addend = point_add(addend, addend)
        k >>= 1

    return result


# --- Key helpers ---

def derive_public_key(d: int) -> Point:
    """
    Compute Q = d*G.
    """
    if not (1 <= d < N):
        raise ValueError("Private key d must be in [1, N-1].")
    Q = scalar_mult(d, G)
    if Q is None or not is_on_curve(Q):
        raise RuntimeError("Derived public key is invalid.")
    return Q